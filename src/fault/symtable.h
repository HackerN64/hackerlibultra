#pragma once

/**
 * @brief Symbol table file header
 *
 * The SYMT file is made of three main tables:
 *
 * * Address table: this is a sequence of 32-bit integers, each representing an address in the ROM.
 *   The table is sorted in ascending order to allow for binary search. Moreover, the lowest 2 bits
 *   of each address can store additional information: If bit 0 is set to 1, the address is the start
 *   of a function. If bit 1 is set to 1, the address is an inline duplicate. In fact, there might be
 *   multiple symbols at the same address for inlined functions, so we need one entry in this table
 *   for each entry; all of them will have the same address, and all but the last one will have bit
 *   1 set to 1.
 * * Symbol table: this is a sequence of symbol table entries, each representing a symbol. The size
 *   of this table (in number of entries) is exactly the same as the address table. In fact, each
 *   address of the address table can be thought of as an external member of this structure; it's
 *   split externally to allow for efficiency reasons. Each entry stores the function name,
 *   the source file name and line number, and the binary offset of the symbol within the containing
 *   function.
 * * String table: this table can be thought as a large buffer holding all the strings needed by all
 *   symbol entries (function names and file names). Each symbol entry stores a string as an offset
 *   within the symbol table and a length. This allows to reuse the same string (or prefix thereof)
 *   multiple times. Notice that strings are not null terminated in the string table.
 *
 * The SYMT file is generated by the n64sym tool during the build process.
 */
typedef struct {
    char head[4];     ///< Magic ID "SYMT"
    u32 version;      ///< Version of the symbol table
    u32 addrtab_off;  ///< Offset of the address table in the file
    u32 addrtab_size; ///< Size of the address table in the file (number of entries)
    u32 symtab_off;   ///< Offset of the symbol table in the file
    u32 symtab_size;  ///< Size of the symbol table in the file (number of entries); always equal to addrtab_size.
    u32 strtab_off;   ///< Offset of the string table in the file
    u32 strtab_size;  ///< Size of the string table in the file (number of entries)
} symtable_header_t;

/** @brief Symbol table entry **/
typedef struct {
    u32 func_sidx; ///< Offset of the function name in the string table
    u32 file_sidx; ///< Offset of the file name in the string table
    u16 func_len;  ///< Length of the function name
    u16 file_len;  ///< Length of the file name
    u16 line;      ///< Line number (or 0 if this symbol generically refers to a whole function)
    u16 func_off;  ///< Offset of the symbol within its function
} symtable_entry_t;

/**
 * @brief Entry in the address table.
 *
 * This is an address in RAM, with the lowest 2 bits used to store additional information.
 * See the ADDRENTRY_* macros to access the various components.
 */
typedef u32 addrtable_entry_t;

#define ADDRENTRY_ADDR(e)      ((e) & ~3) ///< Address (without the flags)
#define ADDRENTRY_IS_FUNC(e)   ((e) & 1)  ///< TRUE if the address is the start of a function
#define ADDRENTRY_IS_INLINE(e) ((e) & 2)  ///< TRUE if the address is an inline duplicate

#define MIPS_OP_ADDIU_SP(op)   (((op) & 0xFFFF0000) == 0x27BD0000) ///< Matches: addiu $sp, $sp, imm
#define MIPS_OP_DADDIU_SP(op)  (((op) & 0xFFFF0000) == 0x67BD0000) ///< Matches: daddiu $sp, $sp, imm
#define MIPS_OP_JR_RA(op)      (((op) & 0xFFFFFFFF) == 0x03E00008) ///< Matches: jr $ra
#define MIPS_OP_SD_RA_SP(op)   (((op) & 0xFFFF0000) == 0xAFBF0000) ///< Matches: sw $ra, imm($sp)
#define MIPS_OP_SD_FP_SP(op)   (((op) & 0xFFFF0000) == 0xAFBE0000) ///< Matches: sw $fp, imm($sp)
#define MIPS_OP_LUI_GP(op)     (((op) & 0xFFFF0000) == 0x3C1C0000) ///< Matches: lui $gp, imm
#define MIPS_OP_NOP(op)        ((op) == 0x00000000)                ///< Matches: nop
#define MIPS_OP_MOVE_FP_SP(op) ((op) == 0x03A0F025)                ///< Matches: move $fp, $sp

symtable_header_t symt_open(void);
addrtable_entry_t symt_addrtab_entry(symtable_header_t* symt, int idx);
addrtable_entry_t symt_addrtab_search(symtable_header_t* symt, u32 addr, int* idx);
char* symt_string(symtable_header_t* symt, int sidx, int slen, char* buf, int size);
void symt_entry_fetch(symtable_header_t* symt, symtable_entry_t* entry, int idx);
char* symt_entry_func(symtable_header_t* symt, symtable_entry_t* entry, u32 addr, char* buf, int size);
char* symt_entry_file(symtable_header_t* symt, symtable_entry_t* entry, char* buf, int size);
